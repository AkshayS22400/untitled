# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1us9wlNzvP_KXKJGj0BqiDrziovXsSTG2
"""

import streamlit as st
import numpy as np
import tensorflow as tf
import os,urllib
import librosa # to extract speech features
import tensorflow as tf

# Save model as a folder (recommended for Python 3.13 / Streamlit Cloud)
model.save("mymodel_v2")  # note: no .h5 extension
print("✅ Model saved successfully in 'mymodel_v2/' folder")

# Later, to load the model
model = tf.keras.models.load_model("mymodel_v2")

import os

print("Current working directory:", os.getcwd())  # check path
model.save("mymodel_v2.h5")  # saves here

model.save("mymodel_v2")  # saves as folder, not .h5

model = tf.keras.models.load_model("mymodel_v2")

import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout, Masking

# Example input shape (change 40 to number of features per audio frame)
input_shape = (None, 40)  # None = variable sequence length

def build_emotion_model(input_shape, num_classes=8):
    """
    Builds an LSTM model for audio emotion detection.

    Args:
        input_shape: tuple, shape of input (timesteps, features)
        num_classes: int, number of emotion categories
    Returns:
        model: compiled tf.keras model
    """
    model = Sequential()
    model.add(Masking(mask_value=0.0, input_shape=input_shape))  # Optional masking for variable-length sequences
    model.add(LSTM(128, return_sequences=True))
    model.add(Dropout(0.3))
    model.add(LSTM(64))
    model.add(Dropout(0.3))
    model.add(Dense(64, activation='relu'))
    model.add(Dense(num_classes, activation='softmax'))

    # Compile model
    model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])
    return model

# Build model
num_emotions = 8  # Example: happy, sad, angry, etc.
model = build_emotion_model(input_shape, num_classes=num_emotions)

# Save new model
model.save("mymodel_v2.h5")
print("✅ New model saved as mymodel_v2.h5")

import tensorflow as tf

# Load the new model safely
model = tf.keras.models.load_model("mymodel_v2.h5")


def main():
    #print(cv2.__version__)
    selected_box = st.sidebar.selectbox(
        'Choose an option..',
        ('Emotion Recognition','view source code')
        )

    if selected_box == 'Emotion Recognition':
        st.sidebar.success('To try by yourself by adding a audio file .')
        application()
    if selected_box=='view source code':
        st.code(get_file_content_as_string("app.py"))

@st.cache(show_spinner=False)
def get_file_content_as_string(path):
    url = 'https://raw.githubusercontent.com/chiluveri-sanjay/Emotion-recognition/main/' + path
    response = urllib.request.urlopen(url)
    return response.read().decode("utf-8")

@st.cache(show_spinner=False)
def load_model():
    model=tf.keras.models.load_model('mymodel.h5')

    return model
def application():
    models_load_state=st.text('\n Loading models..')
    model=load_model()
    models_load_state.text('\n Models Loading..complete')


    file_to_be_uploaded = st.file_uploader("Choose an audio...", type="wav")

    if file_to_be_uploaded:
        st.audio(file_to_be_uploaded, format='audio/wav')
        st.success('Emotion of the audio is  '+predict(model,file_to_be_uploaded))

def extract_mfcc(wav_file_name):
    #This function extracts mfcc features and obtain the mean of each dimension
    #Input : path_to_wav_file
    #Output: mfcc_features'''
    y, sr = librosa.load(wav_file_name)
    mfccs = np.mean(librosa.feature.mfcc(y=y, sr=sr, n_mfcc=40).T,axis=0)

    return mfccs


def predict(model,wav_filepath):
    emotions={1 : 'neutral', 2 : 'calm', 3 : 'happy', 4 : 'sad', 5 : 'angry', 6 : 'fearful', 7 : 'disgust', 8 : 'surprised'}
    test_point=extract_mfcc(wav_filepath)
    test_point=np.reshape(test_point,newshape=(1,40,1))
    predictions=model.predict(test_point)
    print(emotions[np.argmax(predictions[0])+1])

    return emotions[np.argmax(predictions[0])+1]
if __name__ == "__main__":
    main()
